package com.wen.oauth2.algorithm.sort;

/**
 * 排序算法
 *
 * @author huwenwen
 * @since 16/7/15
 */
public class SortAlgorithm {

  private int[] a = {5, 2, 10, 2, 8, 9, 1, 3, 5};

  /**
   * 1. 直接插入排序
   * <p>
   * 基本思想：在要排序的一组数中，假设前面(n-1)[n>=2] 个数已经是排
   * 好顺序的，现在要把第n个数插到前面的有序数中，使得这n个数
   * 也是排好顺序的。如此反复循环，直到全部排好顺序。
   * 2 5 10 2 8 9 1 3 5
   * 2 5 10 10 8 9 1 3 5
   */
  public void directInsertSort() {
    int temp = 0;
    for (int i = 1; i < a.length; i++) {
      int j = i - 1;
      temp = a[i];
      for (; j >= 0 && temp < a[j]; j--) {
        a[j + 1] = a[j];
      }
      a[j + 1] = temp;
    }

    for (int i : a) {
      System.out.println(i);
    }
  }

  /**
   * 2.希尔排序
   * <p>
   * 基本思想：算法先将要排序的一组数按某个增量d（n/2,n为要排序数的个数）
   * 分成若干组，每组中记录的下标相差d.对每组中全部元素进行直接插入排序，
   * 然后再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。
   * 当增量减到1时，进行直接插入排序后，排序完成。
   */
  public void shellSort() {

  }

  /**
   * 3.简单选择排序
   * <p>
   * 在要排序的一组数中，选出最小的一个数与第一个位置的数交换；
   * 然后在剩下的数当中再找最小的与第二个位置的数交换，
   * 如此循环到倒数第二个数和最后一个数比较为止
   */
  public void selectSort() {

  }

  /**
   * 4.堆排序
   * <p>
   * 堆排序是一种树形选择排序，是对直接选择排序的有效改进
   */
  public void HeapSort() {

  }

  /**
   * 5.冒泡排序
   * <p>
   * 在要排序的一组数中，对当前还未排好序的范围内的全部数，
   * 自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，
   * 较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换
   */
  public void bubbleSort() {

  }

  /**
   * 6.快速排序
   * <p>
   * 选择一个基准元素,通常选择第一个元素或者最后一个元素,
   * 通过一趟扫描，将待排序列分成两部分,一部分比基准元素小,
   * 一部分大于等于基准元素,此时基准元素在其排好序后的正确位置,
   * 然后再用同样的方法递归地排序划分的两部分
   */
  public void quickSort() {

  }

  /**
   * 7.归并排序
   * <p>
   * 归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，
   * 即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列
   */
  public void mergeSort() {

  }

  /**
   * 8.基数排序
   * <p>
   * 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。
   * 然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,
   * 数列就变成一个有序序列
   */
  public void radixSort() {

  }

  public static void main(String[] args) {
    SortAlgorithm s = new SortAlgorithm();
    s.directInsertSort();
  }
}
